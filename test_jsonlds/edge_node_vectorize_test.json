[
  {
    "@context": "http://schema.org",
    "@type": "DigitalDocument",
    "name": "22pages_eng.pdf",
    "fileFormat": "application/pdf",
    "headline": "\"RDFGraphGen: A Domain-Agnostic Synthetic RDF Graph Generator Utilizing SHACL Constraints",
    "abstract": [
      "This paper presents RDFGraphGen, an innovative tool designed to generate synthetic RDF graphs based on SHACL (Shapes Constraint Language) constraints. It addresses the issue of insufficient RDF datasets for application testing and benchmarking by utilizing SHACL definitions to produce artificial, yet structurally sound RDF data. The generated data can serve various purposes, including quality control and training for machine learning applications. Furthermore, the tool is open-source and packaged as a Python library, making it accessible for broader usage in the Semantic Web and Linked Data domains.\""
    ],
    "hasPart": [
      {
        "text": "RDFGRAPHGEN: A SYNTHETIC RDF GRAPH GENERATOR BASED ON SHACL CONSTRAINTS A PREPRINT l u J ] E S . s c [ Marija Vecovska, Milos Jovanovik Faculty of Computer Science and Engineering Ss. Cyril and Methodius University in Skopje, N. Macedonia marija.vecovska@students.finki.ukim.mk milos.jovanovik@finki.ukim.mk July 26, 2024 ABSTRACT This paper introduces RDFGraphGen, a general-purpose, domain-independent generator of syn- thetic RDF graphs based on SHACL constraints. The Shapes Constraint Language (SHACL) is a W3C standard which speci\ufb01es ways to validate data in RDF graphs, by de\ufb01ning constraining shapes. However, even though the main purpose of SHACL is validation of existing RDF data, in order to solve the problem with the lack of available RDF datasets in multiple RDF-based application devel- opment processes, we envisioned and implemented a reverse role for SHACL: we use SHACL shape de\ufb01nitions as a starting point to generate synthetic data for an RDF graph. The generation process invol"
      },
      {
        "text": "DF datasets in multiple RDF-based application devel- opment processes, we envisioned and implemented a reverse role for SHACL: we use SHACL shape de\ufb01nitions as a starting point to generate synthetic data for an RDF graph. The generation process involves extracting the constraints from the SHACL shapes, converting the speci\ufb01ed constraints into rules, and then generating arti\ufb01cial data for a prede\ufb01ned number of RDF entities, based on these rules. The purpose of RDFGraphGen is the generation of small, medium or large RDF knowledge graphs for the purpose of benchmarking, testing, quality control, training and other similar pur- poses for applications from the RDF, Linked Data and Semantic Web domain. RDFGraphGen is open-source and is available as a ready-to-use Python package. 1 Introduction The Semantic Web has been a topic of interest for academia and the industry for over two decates now [5]. Over this period, we have witnessed the acceptance of RDF [1] as a standard for representing an"
      },
      {
        "text": "as a ready-to-use Python package. 1 Introduction The Semantic Web has been a topic of interest for academia and the industry for over two decates now [5]. Over this period, we have witnessed the acceptance of RDF [1] as a standard for representing and publishing data on the Web and internally in organizations, along with a plethora of other W3C standards, such as RDFS, OWL, SPARQL, etc. [12]. These standards, most notably RDF, have been widely accepted on the Web, especially after the introduction of Schema.org as a lightweight ontology / vocabulary [11]. Currently, around 50% of the webpages on the Web contain RDF-based metadata [3]. This has also led to the development of many tools, libraries, applications, systems and databases which work with or use RDF as a model for the data. During the development lifecycle of each of them, benchmarking and testing are important steps, which validate the usage scenarios and provide metrics about their real-world usability [4]. These benchmarks "
      },
      {
        "text": "rk with or use RDF as a model for the data. During the development lifecycle of each of them, benchmarking and testing are important steps, which validate the usage scenarios and provide metrics about their real-world usability [4]. These benchmarks and test scenarios sometimes require application-speci\ufb01c or domain-speci\ufb01c RDF datasets, which are not always readily available. This is where synthetic RDF datasets come in. They are datasets which contain entities and data which are arti\ufb01cial, but follow the structure and vocabulary or ontology expected from the application or the system. They ful\ufb01ll the need for data in a speci\ufb01c format, from a speci\ufb01c domain, for an application or a system to be tested or benchmarked [8][9]. Depending on the speci\ufb01c needs, these synthetic RDF datasets can contain from a few, up to millions of different entities and RDF triples [7]. Synthetic RDF data can be created using data generators. These are usually task-speci\ufb01c, i.e. are created for the speci\ufb01c p"
      },
      {
        "text": " speci\ufb01c needs, these synthetic RDF datasets can contain from a few, up to millions of different entities and RDF triples [7]. Synthetic RDF data can be created using data generators. These are usually task-speci\ufb01c, i.e. are created for the speci\ufb01c purpose at hand, when benchmarking or testing a system or an application. What was currently missing, was a generic synthetic RDF data generator, which would be able to generate arti\ufb01cial RDF data from any domain. In order to \ufb01ll this missing piece in the puzzle of the RDF world, we designed and implemented a general-purpose, domain-independent synthetic RDF data generator, based on SHACL constrains. It reverses the role of the Shapes Constraint Language (SHACL), which was designed for validation of existing RDF data; we now use SHACL shapes as a starting point to generate new, arti\ufb01cial RDF data and construct an RDF knowledge graph of the desired size. SHACL is a W3C standard for validating RDF graphs against a set of conditions [2]. These "
      },
      {
        "text": " of existing RDF data; we now use SHACL shapes as a starting point to generate new, arti\ufb01cial RDF data and construct an RDF knowledge graph of the desired size. SHACL is a W3C standard for validating RDF graphs against a set of conditions [2]. These conditions are provided as shapes de\ufb01ned in RDF (shape graph), which are used to validate that a given RDF graph (data graph) satis\ufb01es a set of conditions. However, these shapes can also be viewed as a description of the RDF graphs that do satisfy their conditions. We use this characteristic of SHACL shapes to generate synthetic RDF graphs which satisfy the constraints de\ufb01ned in the shapes. This paper sets to describe the design and implementation of RDFGraphGen - a domain-independent generator of synthetic RDF graphs based on SHACL constraints. The SHACL constraints are used as a description of the structure and data composing the RDF graph, and in accordance with these rules, the corresponding RDF triples are generated. RDFGraphGen is dom"
      },
      {
        "text": "of synthetic RDF graphs based on SHACL constraints. The SHACL constraints are used as a description of the structure and data composing the RDF graph, and in accordance with these rules, the corresponding RDF triples are generated. RDFGraphGen is domain-agnostic, meaning that the source SHACL shapes can be from any domain. The generator can generate an RDF graph with a speci\ufb01ed number of entities, providing \ufb02exibility for the end-users. These small, medium or large RDF datasets (knowledge graphs), generated by RDFGraphGen, can then be used in benchmarking, testing, quality control, training and other similar tasks in the application lifecycle in the domains of RDF, Linked Data and the Semantic Web. Additionally, RDFGraphGen is open-source [20] and is available as a ready-to-use Python package [21]. 2 Related Work Generating synthetic RDF data is not a new topic. It has been of interest to the research community for quite a long time, and here we present a discussion on the existing sol"
      },
      {
        "text": "20] and is available as a ready-to-use Python package [21]. 2 Related Work Generating synthetic RDF data is not a new topic. It has been of interest to the research community for quite a long time, and here we present a discussion on the existing solutions and how our approach relates to them. After that, we present a short overview of SHACL shapes. 2.1 Synthetic RDF Data Generation Tab2KG is a method that is used for interpretation of tables with previously unseen data and automatically infers their semantics to transform them into semantic data graphs [10]. The Tab2KG algorithm transform tabular data into a semantic data graph by automatically inferring the domain ontology and mapping the table columns to the ontology classes and properties, before transforming the rows of the table into RDF triples. This method, despite generating large volumes of RDF data, does not support generating data graphs from a particular user-de\ufb01ned ontology, nor does In other words, the tabular data is pr"
      },
      {
        "text": "es, before transforming the rows of the table into RDF triples. This method, despite generating large volumes of RDF data, does not support generating data graphs from a particular user-de\ufb01ned ontology, nor does In other words, the tabular data is provided, and the ontolology it allow de\ufb01ning rules about the generated data. is adjusted to \ufb01t this data. it takes a description of a target data graph as a SHACL shape, and generates entities according to this description, using random or structured values for the objects in the RDF triples of the generated entities. GAIA is a generic RDF data generator that allows users to generate RDF triples by conforming to any ontology [17]. It is OWL-based, and generates RDF objects based on any properly de\ufb01ned OWL ontology. After testing it, it is apparent that the generator correctly generates a user de\ufb01ned number of objects following the OWL ontology. However, GAIA offers no way to constrain the objects\u2019 values beyond datatype. RDFGraphGen uses a p"
      },
      {
        "text": "e\ufb01ned OWL ontology. After testing it, it is apparent that the generator correctly generates a user de\ufb01ned number of objects following the OWL ontology. However, GAIA offers no way to constrain the objects\u2019 values beyond datatype. RDFGraphGen uses a properly de\ufb01ned SHACL shape as a description of the entities that should be generated, allowing the user to describe the object\u2019s values in great detail, and the generator uses this details to generate more logically correct entities. RDFGraphGen also allows using properties from multiple ontologies in a generated entity, since it doesn\u2019t generate data based on a speci\ufb01c ontology. The ontology is implicitly de\ufb01ned in the SHACL shape via the properties. However, RDFGraphGen is SHACL-based, leading to worse interconnectivity of the generated entities and worse control over the number of generated entities for each class. GRR is a system for generating random RDF data, using SPARQL-like syntax to describe the desired ontology [6]. GRR can gener"
      },
      {
        "text": " to worse interconnectivity of the generated entities and worse control over the number of generated entities for each class. GRR is a system for generating random RDF data, using SPARQL-like syntax to describe the desired ontology [6]. GRR can generate entities using the desired ontology, and it allows the user to provide input for the object\u2019s values. However, GRR offeres no method for constraining the objects\u2019 values beyond providing them beforehead, making the process much more complicated for the user. GRR is much more suitable for generating networks of interconnected entities, according to the user\u2019s de\ufb01nition, which is beyond the capabilities of RDFGraphGen at this time. Our research team has some experience in designing and using RDF data generators in several domains, as well. For instance, in the domain of social network data, for the purpose of benchmarking RDF storage solutions, we have developed a domain-speci\ufb01c RDF dataset generator [19]. It is written in the Java progra"
      },
      {
        "text": "DF data generators in several domains, as well. For instance, in the domain of social network data, for the purpose of benchmarking RDF storage solutions, we have developed a domain-speci\ufb01c RDF dataset generator [19]. It is written in the Java programming language, and builds on a previous generator, in order to improve some of the metrics in the resulting graph and make its features closer to a real-world RDF dataset. Aside from this, our team has also worked with other RDF graph generators, for instance in the \ufb01eld of geo-spatial data [16][15][14] and in benchmarking RDF storage solution [13][18]. All of these examples include purpose-built RDF data generators, which serve a speci\ufb01c need. In contrast, our approach with RDFGraphGen is to provide a general-purpose, domain-independent generator which can work for any scenario. 2.2 A Brief Overview of SHACL Shapes SHACL (Shapes Constraint Language) is a W3C standard used to validate RDF data against a set of conditions, known as shapes, "
      },
      {
        "text": "rovide a general-purpose, domain-independent generator which can work for any scenario. 2.2 A Brief Overview of SHACL Shapes SHACL (Shapes Constraint Language) is a W3C standard used to validate RDF data against a set of conditions, known as shapes, ensuring the data conforms to speci\ufb01c requirements [2]. It enables the de\ufb01nition of constraints on RDF graphs, enabling validation and veri\ufb01cation of data in a structured and standardized way. A SHACL shape determines how to validate a focus node based on the values of properties and other characteristics of the focus node. For example, shapes can declare a condition that a focus node has a particular value for a given property, along with a minimum number of values for the property. The shapes are written in RDF, as well, forming SHACL graphs. SHACL de\ufb01nes two types of shapes: Node shapes: shapes about the focus node itself, \u2022 Property shapes: shapes about the values of a particular property or path for the focus node. A single SHACL graph"
      },
      {
        "text": "are written in RDF, as well, forming SHACL graphs. SHACL de\ufb01nes two types of shapes: Node shapes: shapes about the focus node itself, \u2022 Property shapes: shapes about the values of a particular property or path for the focus node. A single SHACL graph can contain multiple node shapes. Each node shape usually contains multiple property shapes. Below we show an example of a SHACL shape with a focus node that represents a person. The SHACL shapes graph in this example contains one nodes shape, ex:PersonShape. This shape targets any ex:Person entity in the RDF data graph. The node shape contains three property shapes which describe the properties of the target node. The \ufb01rst property shape constraints the person\u2019s name, the second constraints its birth date and the third its gender. A property shape describes a property in an RDF data graph. The property is speci\ufb01ed as the object in the RDF triple where the property shape is the subject (usually a blank node), and sh:path is the predicate, "
      },
      {
        "text": "s birth date and the third its gender. A property shape describes a property in an RDF data graph. The property is speci\ufb01ed as the object in the RDF triple where the property shape is the subject (usually a blank node), and sh:path is the predicate, i.e. ex:name, ex:birthData and ex:gender in this case. 3 RDFGraphGen RDFGraphGen is a generic RDF graph generator that generates RDF entities according to a provided SHACL shapes graph. RDFGraphGen is domain-agnostic, and can be used in multiple scenarios where non-speci\ufb01c RDF data is needed, such as application or algorithm testing, system and tool benchmarking, software quality control, training of machine learning models, etc. In this section we will go into the details of how it was designed and implemented, and we will present several examples which showcase how it works in practice. 3.1 Design SHACL shape graphs were introduced as a standardized way to validate that a given dataset of RDF data satis\ufb01es a given set of conditions. Howev"
      },
      {
        "text": " and implemented, and we will present several examples which showcase how it works in practice. 3.1 Design SHACL shape graphs were introduced as a standardized way to validate that a given dataset of RDF data satis\ufb01es a given set of conditions. However, the same SHACL shape graphs can also be viewed as a description of the RDF data graphs that do satisfy these conditions [2]. RDFGraphGen uses these conditions as rules to generate synthetic data into RDF graphs, that conform to the description provided in the SHACL shape graphs. First, let us look into the overall structure of the generator. The generator consists of an extracting component and a generating component. A SHACL shape graphs can describe one or multiple different data graphs. Each data graph is separately described by a SHACL node shape. These SHACL node shapes can contain multiple SHACL property shapes which describe the triples in the RDF data graphs. First, given a SHACL shapes graph, the extracting component analyzes i"
      },
      {
        "text": "ach data graph is separately described by a SHACL node shape. These SHACL node shapes can contain multiple SHACL property shapes which describe the triples in the RDF data graphs. First, given a SHACL shapes graph, the extracting component analyzes it, locates all of the SHACL node shapes described in it, and creates a shape map for each of them. A shape map contains the description of a speci\ufb01c SHACL node shape. Then, the generating component generates a speci\ufb01ed number of RDF entities into an RDF data graph, using the shape maps as templates. The Generation Steps. The RDFGraphGen is intended to be used in the following way: the user provides a Turtle (.ttl) \ufb01le which contains a SHACL shapes graph (e.g. input-shapes.ttl), an empty Turtle \ufb01le in which the generated RDF will be written into (e.g. output-graph.ttl), and the number of entities which should be generated (entityCount). After the generation process has \ufb01nished, the generated RDF data graph can be accessed via the output \ufb01le "
      },
      {
        "text": "le in which the generated RDF will be written into (e.g. output-graph.ttl), and the number of entities which should be generated (entityCount). After the generation process has \ufb01nished, the generated RDF data graph can be accessed via the output \ufb01le (e.g. output-graph.ttl). The generation process consists of the following steps: Step 1: The generator gets, reads and parses the input \ufb01le which contains the SHACL shapes graph. \u2022 Step 2: Next, the generator identi\ufb01es the SHACL node shapes. \u2022 Step 3: The generator creates a shape map for each separate SHACL node shape. It stores all of these separate shape maps in a single root shape map. Step 4: The generator generates RDF entities with their corresponding properties and values as separate smaller RDF data graphs, based on the shape maps. Step 5: The generator writes out the generated RDF data graphs into a single RDF data graph, into the output \ufb01le. In the next section, we will present a more in-depth explanation of how the RDFGraphGen g"
      },
      {
        "text": "ller RDF data graphs, based on the shape maps. Step 5: The generator writes out the generated RDF data graphs into a single RDF data graph, into the output \ufb01le. In the next section, we will present a more in-depth explanation of how the RDFGraphGen generator achieves this. 3.2 Implementation In this section we will describe the implementation of the RDFGraphGen generator. RDFGraphGen was coded using the Python programming language, and it uses a few Python libraries: rdflib for RDF graph functionality and exrex for generating strings using regular expressions. 3.2.1 Step 1 & 2: Finding the SHACL Node Shapes Reading and parsing the input Turtle \ufb01le in Python is trivial. The SHACL node shapes are usually the subject in an RDF triple where the predicate is the rdf:type predicate and the object is sh:NodeShape. RDFGraphGen selects there triples and extracts the node shapes and their de\ufb01nitions. 3.2.2 Step 3: Creating a Shape Map The next step is to extract the constraints for each node sha"
      },
      {
        "text": " predicate is the rdf:type predicate and the object is sh:NodeShape. RDFGraphGen selects there triples and extracts the node shapes and their de\ufb01nitions. 3.2.2 Step 3: Creating a Shape Map The next step is to extract the constraints for each node shape from the SHACL graph, to create a sub-dictionary for each separate shape, and to provide a simple way for accessing the options from the SHACL lists - used for logical constraint components and sh:in. RDFGraphGen extracts the description of the target data graph from the corresponding SHACL node shape and its nested property shapes in a structure called a shape map. A shape map is a dictionary-like structure representation of a SHACL shape. The property shapes which are nested in a node shape, are also represented by shape maps and stored as properties in the shape map of their node shape. To explain the procedure more precisely, we provide a list of de\ufb01nitions. The de\ufb01nitions relating to SHACL shapes are reiterated from the SHACL standa"
      },
      {
        "text": ", are also represented by shape maps and stored as properties in the shape map of their node shape. To explain the procedure more precisely, we provide a list of de\ufb01nitions. The de\ufb01nitions relating to SHACL shapes are reiterated from the SHACL standard [2] in our context, while the others, relating to shape maps, are our own. De\ufb01nition 1: A SHACL node shape NS is a subject of an RDF triple where the predicate is rdf:type and the object is sh:NodeShape. De\ufb01nition 2: A SHACL property shape PS is the object of an RDF triple where the subject is an NS and the predicate is sh:property. De\ufb01nition 4: A SHACL shapes graph ShapesG is an RDF graph that contains SHACL shapes (S). Each shapes graph contains n shapes: S1,...,Sn De\ufb01nition 5: A property Pi is the object of an RDF triple where the subject is a SHACL property shape P Si and the predicate is sh:path. De\ufb01nition 6: We de\ufb01ne SMi as the shape map of the shape Si. SMi contains the constraints de\ufb01ned for Si in the source SHACL shapes graph (S"
      },
      {
        "text": "i is the object of an RDF triple where the subject is a SHACL property shape P Si and the predicate is sh:path. De\ufb01nition 6: We de\ufb01ne SMi as the shape map of the shape Si. SMi contains the constraints de\ufb01ned for Si in the source SHACL shapes graph (ShapesG). De\ufb01nition 7: We de\ufb01ne SM properties as the structure in a shape map (SM) that contains other shape maps (SM). De\ufb01nition 8: A shape Si contains a property shape P Si if Si is the subject of an RDF triple where the predicate is sh:property and the object is P Si. De\ufb01nition 9: A shape Si points to a shape Sj if there exists a shape Sk, such that Si contains Sk directly or indirectly, and there exists an RDF triple where Sk is the subject, sh:node is the predicate and Sj is the object. Algorithm 1 describes how a shape S is transformed into a shape map SM, while handling all of its nested shapes. This algorithm is recursive and is used for mapping all of the SHACL shapes from the source SHACL document, into their corresponding shape ma"
      },
      {
        "text": "rithm 1 describes how a shape S is transformed into a shape map SM, while handling all of its nested shapes. This algorithm is recursive and is used for mapping all of the SHACL shapes from the source SHACL document, into their corresponding shape maps. Add predicate : object pair to SM In Algorithm 1, ShapesG is a shapes graph which contains one or more shapes. Each node shape N S1,...,N Sn in the ShapesG graph is transformed into a shape map SM1,...,SMn accordingly, and added to SM0, as N Si : SMi key - value pairs. Here, SM0 represents the root shape map that represents the shapes graph. Each node shape N Si can contain zero or more property shapes P S1,...,P Sn. If a N Si contains at least one P S, a structure SM_properties is added to SMi, to store the shape maps for each P S. For each P Sj contained in a N Si, a SMj is added to SM_properties, as a Pj : SMj key - value pair, where Pj is the property described by P Sj. If P Sj contains another property shape P Sk, the same procedur"
      },
      {
        "text": "SMi, to store the shape maps for each P S. For each P Sj contained in a N Si, a SMj is added to SM_properties, as a Pj : SMj key - value pair, where Pj is the property described by P Sj. If P Sj contains another property shape P Sk, the same procedure is repeated. If not, the SHACL constraints from Pj are added to SMj. The last 2 steps are repeated until there are no more nested property shapes. To illustrate the procedure, let\u2019s use the SHACL shape from Example 1. Below is the root shape map for it, presented as Example 2. Example 2: A Shape Map for the SHACL Shape from Example 1 De\ufb01nition 3: A SHACL shape S is either a SHACL node shape (NS) or a property shape (PS). 3.2.3 Step 4 & 5: Generating the RDF Entities The \ufb01nal two steps of the RDFGraphGen procedure is the actual generation of the synthetic RDF triples, which will comprise the synthetic RDF knowledge graph, and its serialization into an output \ufb01le. The synthetic RDF graphs are generated based on the shape maps which are the "
      },
      {
        "text": "DFGraphGen procedure is the actual generation of the synthetic RDF triples, which will comprise the synthetic RDF knowledge graph, and its serialization into an output \ufb01le. The synthetic RDF graphs are generated based on the shape maps which are the result of Step 3, as described in the previous section. The SHACL constraints [2] translated from the source SHACL document into the shape maps, describe precisely and in great detail how the generated RDF triples should look like: the value type constraint components de\ufb01ne an ontology type for the generated entity; the cardinality constraint components denote the number of entities / values which should be generated; the value range constraint components and string-based constraint components describe the format, pattern and length of the values which should be generated; the property pair constraint components provide a way to constrain the value of one object based on the value of an object in another triple; the logical constraint compo"
      },
      {
        "text": "escribe the format, pattern and length of the values which should be generated; the property pair constraint components provide a way to constrain the value of one object based on the value of an object in another triple; the logical constraint components offer a choice of constraints to choose from while generating the synthetic data. Below, we present Algorithm 2 which describes how a shape map created in Step 3 is used to generate synthetic RDF triples and recursively add them to the resulting synthetic RDF knowledge graph. The process of generating synthetic RDF triples, presented in Algorithm 2, is a recursive algorithm comprised of the following main steps: First, all of the shape maps (SM1 ... SMn) based on node shapes which are not pointed to by another shape, are located. For each SMi from the previous step, an unnamed node N odei is generated and added to the result graph G. If SMi contains properties, represented by the SM properties structure, a triple is added to the resul"
      },
      {
        "text": "pointed to by another shape, are located. For each SMi from the previous step, an unnamed node N odei is generated and added to the result graph G. If SMi contains properties, represented by the SM properties structure, a triple is added to the result graph G for each property-map pair Pj : SMj in SM properties. In the triple, N odei is the subject, Pj is the predicate and MapToRDF(SMj, G) is the object, i.e. the triple is structured as N odei \u2192 Pj \u2192 MapToRDF(SMj, G). MapToRDF(SMj, G) is the result node or literal generated recursively based on SMj. If SMi contains no SM properties, a literal is generated and added as an object in the triple. If N Si points to another node shape N Sk, a number of entities Ek(1),...,Ek(f ) are generated based on SMk. The number is determined by the SHACL constraints for N Sk. Generating Values. The generated synthetic object values in an RDF knowledge graph can be domain-speci\ufb01c or random, depending on whether the generated entity adheres to a known typ"
      },
      {
        "text": "d on SMk. The number is determined by the SHACL constraints for N Sk. Generating Values. The generated synthetic object values in an RDF knowledge graph can be domain-speci\ufb01c or random, depending on whether the generated entity adheres to a known type from a well-known ontology, on the predicate used in the triple and on the SHACL constraints de\ufb01ned for the property in question. In Algorithm 2, the process of generating an object value is replaced with the GenerateObject() function. Below, we will describe the process of generating an object\u2019s value in a synthetic RDF triple. When generating an object, the \ufb01rst step is to try and infer what would be it\u2019s logical value, given the predicate and the RDF type of the entity as de\ufb01ned in the input SHACL shape. For example, if a triple is being generated for an entity of type schema:Person from the widely used Schema.org vocabulary [11], where the predicate is schema:firstName, it is natural that the generated value of the object should be a "
      },
      {
        "text": "t SHACL shape. For example, if a triple is being generated for an entity of type schema:Person from the widely used Schema.org vocabulary [11], where the predicate is schema:firstName, it is natural that the generated value of the object should be a human \ufb01rst name. In this case, the generator can pick a \ufb01rst name randomly from a set of pre-generated \ufb01rst names which it uses as a dictionary. The generator contains sets of pre-generated values for the most common properties from Schema.org, and for these properties values are randomly selected from these sets by the RDFGraphGen generator. Even though the current version of the generator has an implementation of this functionality for a several entity types from the Schema.org vocabulary, it can easily be expanded to include more types from different ontologies, either general or domain-speci\ufb01c. If the type of the entity for which a triple is being generated is unknown, the name of the predicate in the triple can provide useful informati"
      },
      {
        "text": "can easily be expanded to include more types from different ontologies, either general or domain-speci\ufb01c. If the type of the entity for which a triple is being generated is unknown, the name of the predicate in the triple can provide useful information concerning the value of the object. For example, if the name of the predicate is birthDate, from a random or unknown ontology, the word date suggests that the object should be a date. Furthermore, if the predicate name contains the word telephone or phone and no data concerning the pattern is found in the input SHACL shape, a general pattern for a telephone number can be used by the generator to generate a random value which will make the generated synthetic RDF triple more relevant. The generator can easily be expanded to include more rules which are based on the names of previously unknown predicates it comes across. When the value of the object cannot be picked from a pre-de\ufb01ned set of speci\ufb01c values, a function for generating a rando"
      },
      {
        "text": "rator can easily be expanded to include more rules which are based on the names of previously unknown predicates it comes across. When the value of the object cannot be picked from a pre-de\ufb01ned set of speci\ufb01c values, a function for generating a random, synthetic value is called. This function uses all of the constraints de\ufb01ned in the input SHACL shape which are related to the object, and which carry useful information about the object and its value. This function generates an object or a literal value based on a number of SHACL constraints: datatype, minimum length, maximum length, pattern, minimum and maximum value, etc. This last part is what makes the RDFGraphGen generator general purpose and domain-independent: it can generate synthetic RDF triples and graphs from any domain, regardless of if it is explicitly familiar with it or not. The pre- generated sets of \ufb01rst names, last names, street names, professions, movie titles, book titles, etc., are solely good to have features, which"
      },
      {
        "text": " RDF triples and graphs from any domain, regardless of if it is explicitly familiar with it or not. The pre- generated sets of \ufb01rst names, last names, street names, professions, movie titles, book titles, etc., are solely good to have features, which increase the quality of the generated RDF knowledge graphs. However, that does not diminish the value of the synthetic graphs which the RDFGraphGen generator can generate when it works with a new and unfamiliar domain. The generality of RDFGraphGen is its most prominent feature. Outputting the Synthetic RDF Graph. As a \ufb01nal step, the generator outputs the generated synthetic RDF graph into the output Turtle \ufb01le. This \ufb01le contains all synthetic RDF triples generated in the previous step. As we mentioned before, the RDFGraphGen generator also uses the input parameter entityCount. This parameter determines the size of the generated synthetic RDF graph, which can be anything from a single entity, to a graph containing billions of RDF triples. "
      },
      {
        "text": "entioned before, the RDFGraphGen generator also uses the input parameter entityCount. This parameter determines the size of the generated synthetic RDF graph, which can be anything from a single entity, to a graph containing billions of RDF triples. For the sake of simplicity, the number of entities to be generated relates to the \ufb01rst node graph contained in the input SHACL graph, in cases when multiple node graphs are present in it. The number of entities from the other node graphs will be determined by the relation between the \ufb01rst node graph and the other node graphs (e.g. similarly to the example presented in Section 3.3, where each person can have one or no addresses), or the generator will generate the same amount of entities from it as well, if it is not related to the \ufb01rst node graph. 3.3 Generated Example using \u201cschema:Person\u201d In order to showcase how RDFGraphGen works for speci\ufb01c SHACL shapes as inputs, we present here one example of using the schema:Person class from Schema."
      },
      {
        "text": "as well, if it is not related to the \ufb01rst node graph. 3.3 Generated Example using \u201cschema:Person\u201d In order to showcase how RDFGraphGen works for speci\ufb01c SHACL shapes as inputs, we present here one example of using the schema:Person class from Schema.org. Other examples, from various domains, using ontologies and types which are familiar or not to the generator, are presented in Appendix A. Even more examples are available on the project\u2019s GitHub page [20]. In this example, the input SHACL shape refers to entities of the type schema:Person. From the de\ufb01nition, each such entity is constrained by SHACL to have: a given name and a last name, or a full name; exactly one date of birth, which will be earlier then a possible death date; a gender with one of the two available values; an email; a job title; a telephone number; an address, which has a speci\ufb01ed complex type (it\u2019s an object, not a literal). Additionally, the address objects have a street address which is a string value; a postal co"
      },
      {
        "text": "th one of the two available values; an email; a job title; a telephone number; an address, which has a speci\ufb01ed complex type (it\u2019s an object, not a literal). Additionally, the address objects have a street address which is a string value; a postal code which can be a string or an integer with values between 10.000 - 99.999. The content of the input SHACL shape \ufb01le is presented below: After running the RDFGraphGen generator on the input SHACL shapes \ufb01le, and setting the parameter entityCount to 2, this is an example of a generated synthetic RDF graph: <http://example.org/ns#Node103> schema:postalCode \"Fh6UpXLm\" ; schema:streetAddress \"no. 1 Gillette ave\" ; sh:description schema:AddressShape . Let us have a look at some of the noteworthy aspects of what happens when RDFGraphGen generates the synthetic RDF graph in this case. First, when it generates the name of each person entity, only one option from the xone constraint can be selected. In the \ufb01rst entity, the person has separate proper"
      },
      {
        "text": "cts of what happens when RDFGraphGen generates the synthetic RDF graph in this case. First, when it generates the name of each person entity, only one option from the xone constraint can be selected. In the \ufb01rst entity, the person has separate properties for the \ufb01rst name and the surname. In the second entity, the person has a single property for the full name, and the full name includes both the \ufb01rst name and the surname, as a single value. Further, properties related to dates have a date value for the object, despite not containing a datatype con- straint in the description. The generator extracts information from the property names schema:birthDate and schema:deathDate, and determines that the objects\u2019 values in the generated RDF triples should be dates. The email values are comprised of the \ufb01rst name and the surname of the person. This has been speci\ufb01cally prede\ufb01ned in the generator, when working with schema:Person entities and their email addresses. Some level of randomness is sti"
      },
      {
        "text": " should be dates. The email values are comprised of the \ufb01rst name and the surname of the person. This has been speci\ufb01cally prede\ufb01ned in the generator, when working with schema:Person entities and their email addresses. Some level of randomness is still included with the delimiter between the \ufb01rst name and surname in the email address. The generated phone numbers follow a speci\ufb01c pattern, because the generator recognizes that the value of the object should be a phone number. This is again based on the property name, \u2019schema:telephone\u2019 in this case, so the generator applies the prede\ufb01ned pattern constraint. The address for each person is generated as a separate RDF entity, based on the SHACL shape in the input \ufb01le, which constrains the address. 3.4 Packaging as a Python library In order to make the RDFGraphGen generator more easily available for the community, we packaged it as a Python library and published it online. Now, any interested stakeholder can get it locally and use it as a co"
      },
      {
        "text": "s. 3.4 Packaging as a Python library In order to make the RDFGraphGen generator more easily available for the community, we packaged it as a Python library and published it online. Now, any interested stakeholder can get it locally and use it as a command-line tool. RDFGraphGen is available via the command: pip install rdf-graph-gen, which downloads and installs it lo- cally on the user machine. Afterwards, RDFGraphGen can be used via the command-line, using the command: rdfgen input-shape.ttl output-graph.ttl entity-count The command rdfgen takes three arguments as input: The \ufb01le containing the input SHACL graph (e.g. input-shape.ttl), \u2022 The \ufb01le where the generated synthetic RDF graph is to be written (e.g. output-graph.ttl), and \u2022 The number of entities to be generated. The full RDFGraphGen code, along with the CSV \ufb01les containing pre-de\ufb01ned sets of values, examples of SHACL shape \ufb01les and generated graph examples, are publicly available as a GitHub repository1 [20]. Using a CI/CD pi"
      },
      {
        "text": "ber of entities to be generated. The full RDFGraphGen code, along with the CSV \ufb01les containing pre-de\ufb01ned sets of values, examples of SHACL shape \ufb01les and generated graph examples, are publicly available as a GitHub repository1 [20]. Using a CI/CD pipeline based on GitHub actions, we release a new version of the RDFGraphGen generator on PyPi every time there is a change in the GitHub repository. The project is publicly available on PyPi2 [21]. 4 Discussion and Future Work This is the \ufb01rst iteration and the \ufb01rst release of the RDFGraphGen generator. Even though it is general-purpose and can be used in any domain, we added a few additional rules for the most commonly used ontologies and their classes, in order to make a more user-friendly output of generated RDF triples, where the values are not completely random. This approach has its drawbacks: a question arises as to why were these speci\ufb01c ontologies and classes chosen over others, why was the list not expanded, etc. These are all val"
      },
      {
        "text": "put of generated RDF triples, where the values are not completely random. This approach has its drawbacks: a question arises as to why were these speci\ufb01c ontologies and classes chosen over others, why was the list not expanded, etc. These are all valid questions, and the answer is that we had to stop somewhere, and release this \ufb01rst version. In the future, we plan to address several shortcomings of RDFGraphGen. Currently, the interconnections among entities in the generated RDF graphs are limited, so our focus will be on producing more interconnected data graphs. Additionally, we aim to introduce an interface which will allow users to have a better control of the number of entities 1RDFGraphGen on GitHub: https://github.com/mveco/RDFGraphGen 2RDFGraphGen on PyPi: https://pypi.org/project/rdf-graph-gen/ generated for each node shape de\ufb01ned in the SHACL shapes graph, as well as enhance control over the connections between these generated entities. The next step will involve thorough test"
      },
      {
        "text": "n 2RDFGraphGen on PyPi: https://pypi.org/project/rdf-graph-gen/ generated for each node shape de\ufb01ned in the SHACL shapes graph, as well as enhance control over the connections between these generated entities. The next step will involve thorough testing of the generator\u2019s capabilities, followed by a comparison with other similar generators. Furthermore, adding support for multiple ontologies, their types, and properties is an ongoing task that we will continue to work on. Additionally, in order to decentralize and democratize the work on RDFGraphGen, we have published it as open- source, so any interested stakeholder can either join in its collaborative development via GitHub, or fork it and make their own version of it. 5 Conclusion In this paper, we introduce RDFGraphGen, a general-purpose, domain-agnostic synthetic RDF graphs generator, which is based on SHACL constraints. Even though generators for synthetic RDF data have been developed in the past, this is the \ufb01rst time a domain-i"
      },
      {
        "text": "s paper, we introduce RDFGraphGen, a general-purpose, domain-agnostic synthetic RDF graphs generator, which is based on SHACL constraints. Even though generators for synthetic RDF data have been developed in the past, this is the \ufb01rst time a domain-independent generator is introduced, and it is the \ufb01rst time a generator is based on SHACL constraints. Even though the SHACL standard has been developed for the purpose of validating existing RDF data, we reverse its role here and use it as a starting point to generate new, synthetic RDF data which are aligned with the constraints de\ufb01ned by the SHACL shapes. The synthetic RDF knowledge graphs, generated by RDFGraphGen, can be used in many different scenarios in the software development cycle, in the domains of RDF data, Linked Data and the Semantic Web, such as: application testing, algorithm testing, application benchmarking, software quality control, training of machine learning models, etc. The domain independence feature of RDFGraphGen "
      },
      {
        "text": " the domains of RDF data, Linked Data and the Semantic Web, such as: application testing, algorithm testing, application benchmarking, software quality control, training of machine learning models, etc. The domain independence feature of RDFGraphGen is its main feature: the generated RDF graph will contain data from the domain which is described in the source SHACL shapes \ufb01le. It can be data about people, movies, events, web pages, books, temperature measurements, scienti\ufb01c experiments, healthcare records, gene data, geographic locations, social media interactions, \ufb01nancial transactions, e-commerce products, biodiversity records, transportation schedules, educational courses, etc. Given the generality of SHACL and its approach, the same generality is available via the RDFGraphGen generator, as well. In order to make the generated RDF graphs and the values in it more user-friendly, and closer to real-world values, the generator is able to recognize some of the most common classes and pr"
      },
      {
        "text": "erality is available via the RDFGraphGen generator, as well. In order to make the generated RDF graphs and the values in it more user-friendly, and closer to real-world values, the generator is able to recognize some of the most common classes and properties from the Schema.org ontology. Additionally, the generator can use the name of a given predicate to detect some of the more common datatypes, such as date, phone, email, etc. This reduces the amount of gibberish data, which is structurally valid from a SHACL point of view, but can be unwanted in some scenarios. RDFGraphGen is very user-friendly: it can produce a large RDF knowledge graph with synthetic data, based on one or multiple SHACL shapes from a given domain, with just a single command-line instruction. The amount of RDF entities in the generated data can be controlled directly by the user. The code of the RDFGraphGen generator is publicly available via its GitHub repository. It is also available as a public Python library, h"
      },
      {
        "text": "mmand-line instruction. The amount of RDF entities in the generated data can be controlled directly by the user. The code of the RDFGraphGen generator is publicly available via its GitHub repository. It is also available as a public Python library, hosted on PyPi, making it available for use by any interested user via a command-line interface. This approach also allows us to further develop the generator and make the new changes transparent via these two public locations. References [1] RDF 1.1 Concepts and Abstract Syntax. https://www.w3.org/TR/rdf11-concepts/. [2] Shapes Constraint Language (SHACL). https://www.w3.org/TR/shacl/. [3] Web Data Commons - RDFa, Microdata, Embedded JSON-LD, and Microformats Data Sets - October 2023. http://webdatacommons.org/structureddata/2023-12/stats/stats.html. [4] Renzo Angles, Peter Boncz, Josep Larriba-Pey, Irini Fundulaki, Thomas Neumann, Orri Erling, Peter Neubauer, Norbert Martinez-Bazan, Venelin Kotsev, and Ioan Toma. The Linked Data Benchmark "
      },
      {
        "text": "datacommons.org/structureddata/2023-12/stats/stats.html. [4] Renzo Angles, Peter Boncz, Josep Larriba-Pey, Irini Fundulaki, Thomas Neumann, Orri Erling, Peter Neubauer, Norbert Martinez-Bazan, Venelin Kotsev, and Ioan Toma. The Linked Data Benchmark Council: A Graph and RDF Industry Benchmarking Effort. ACM SIGMOD Record, 43(1):27\u201331, 2014. [5] Tim Berners-Lee, James Hendler, and Ora Lassila. The Semantic Web: A New Form of Web Content that is Meaningful to Computers will Unleash a Revolution of New Possibilities. In Linking the World\u2019s Information: Essays on Tim Berners-Lee\u2019s Invention of the World Wide Web, pages 91\u2013103. 2023. [6] Daniel Blum and Sara Cohen. Generating RDF for Application Testing. In 9th International Semantic Web Conference ISWC 2010, page 105, 2010. [7] Songyun Duan, Anastasios Kementsietsidis, Kavitha Srinivas, and Octavian Udrea. Apples and Oranges: A Comparison of RDF Benchmarks and Real RDF Datasets. In Proceedings of the 2011 ACM SIGMOD Interna- tional Confere"
      },
      {
        "text": "nce ISWC 2010, page 105, 2010. [7] Songyun Duan, Anastasios Kementsietsidis, Kavitha Srinivas, and Octavian Udrea. Apples and Oranges: A Comparison of RDF Benchmarks and Real RDF Datasets. In Proceedings of the 2011 ACM SIGMOD Interna- tional Conference on Management of Data, pages 145\u2013156, 2011. [8] Kleanthi Georgala, Mirko Spasi\u00b4c, Milos Jovanovik, Henning Petzka, Michael R\u00a8oder, and Axel-Cyrille Ngonga Ngomo. MOCHA2017: The Mighty Storage Challenge at ESWC 2017. In Semantic Web Challenges, pages 3\u201315, 2017. [9] Kleanthi Georgala, Mirko Spasi\u00b4c, Milos Jovanovik, Vassilis Papakonstantinou, Claus Stadler, Michael R\u00a8oder, and Axel-Cyrille Ngonga Ngomo. MOCHA2018: The Mighty Storage Challenge at ESWC 2018. In Semantic Web Challenges, pages 3\u201316, 2018. [10] Simon Gottschalk and Elena Demidova. Tab2KG: Semantic Table Interpretation With Lightweight Semantic Pro\ufb01les. Semantic Web, 13(3):571\u2013597, 2022. [11] Ramanathan V Guha, Dan Brickley, and Steve Macbeth. Schema.org: Evolution of Structur"
      },
      {
        "text": "16, 2018. [10] Simon Gottschalk and Elena Demidova. Tab2KG: Semantic Table Interpretation With Lightweight Semantic Pro\ufb01les. Semantic Web, 13(3):571\u2013597, 2022. [11] Ramanathan V Guha, Dan Brickley, and Steve Macbeth. Schema.org: Evolution of Structured Data on the Web. Communications of the ACM, 59(2):44\u201351, 2016. [12] Aidan Hogan. The Semantic Web: Two Decades On. Semantic Web, 11(1):169\u2013185, 2020. [13] Milos Jovanovik and Mirko Spasi\u00b4c. Benchmarking Virtuoso 8 at the Mighty Storage Challenge 2018: Challenge Results. In Semantic Web Challenges, pages 24\u201335, 2018. [14] Milos Jovanovik and Mirko Spasi\u00b4c. Transforming Geospatial RDF Data into GeoSPARQL-Compliant Data: A Case of Traf\ufb01c Data. In Proceedings of the 16th International Conference on Informatics and Information Technologies, pages 76\u201381, May 2019. [15] Milos Jovanovik, Timo Homburg, and Mirko Spasi\u00b4c. Software for the GeoSPARQL Compliance Benchmark. Software Impacts, 8:100071, 2021. doi: https://doi.org/10.1016/j.simpa.2021.10"
      },
      {
        "text": "on Informatics and Information Technologies, pages 76\u201381, May 2019. [15] Milos Jovanovik, Timo Homburg, and Mirko Spasi\u00b4c. Software for the GeoSPARQL Compliance Benchmark. Software Impacts, 8:100071, 2021. doi: https://doi.org/10.1016/j.simpa.2021.100071. [16] Milos Jovanovik, Timo Homburg, and Mirko Spasi\u00b4c. A GeoSPARQL Compliance Benchmark. ISPRS Interna- tional Journal of Geo-Information, 10(7), 2021. doi: 10.3390/ijgi10070487. [17] Tanguy Raynaud, Samir Amir, and Ra\ufb01qul Haque. A Generic and High-Performance RDF Instance Generator. International Journal of Web Engineering and Technology, 11(2):133\u2013152, 2016. [18] Mirko Spasi\u00b4c and Milos Jovanovik. MOCHA 2017 as a Challenge for Virtuoso. In Semantic Web Challenges, pages 21\u201332, 2017. [19] Mirko Spasi\u00b4c, Milos Jovanovik, and Arnau Prat-P\u00b4erez. An RDF Dataset Generator for the Social Network Benchmark with Real-World Coherence. In Workshop on Benchmarking Linked Data (BLINK 2016), at the 15th International Semantic Web Conference (ISWC"
      },
      {
        "text": " Mirko Spasi\u00b4c, Milos Jovanovik, and Arnau Prat-P\u00b4erez. An RDF Dataset Generator for the Social Network Benchmark with Real-World Coherence. In Workshop on Benchmarking Linked Data (BLINK 2016), at the 15th International Semantic Web Conference (ISWC 2016), 2016. [20] Marija Vecovska and Milos Jovanovik. RDFGraphGen on GitHub, 2024. https://github.com/mveco/RDFGraphGen. RDFGraphGen 2024. [20] Marija Vecovska and Milos Jovanovik. https://github.com/mveco/RDFGraphGen. and https://pypi.org/project/rdf-graph-gen/. RDFGraphGen on PyPi, 2024. Appendix A More Generated Examples In order to add more context and practically showcase the way the RDFGraphGen works, we will present several more examples of input SHACL shapes and generated synthetic RDF knowledge graphs based on them. Additional examples are available on the RDFGraphGen GitHub page [20]. A.1 An Example of Using the \u201cschema:Book\u201d Class from Schema.org This example uses the schema:Book class from the Schema.org vocabulary [11]. This "
      },
      {
        "text": " knowledge graphs based on them. Additional examples are available on the RDFGraphGen GitHub page [20]. A.1 An Example of Using the \u201cschema:Book\u201d Class from Schema.org This example uses the schema:Book class from the Schema.org vocabulary [11]. This class represents entities which are books, and the input SHACL shape \ufb01le, listed below, contains constraints for each book entity, such as: each book can have an identi\ufb01er which follows a speci\ufb01c pattern; each book can have a name which is a string; each book can have exactly one ISBN identi\ufb01er; each book can have between 1 and 3 authors; etc. Additionally, the SHACL shape \ufb01le contains a node shape for schema:Author entities as well, which represent the book authors. The SHACL constraints for the author entities specify that they each must have: a given name; a possible birth date and a death date; gender; an email address; etc. input-shape-books.ttl schema:BookShape After running RDFGraphGen on the input SHACL shapes \ufb01le listed above, and "
      },
      {
        "text": "e author entities specify that they each must have: a given name; a possible birth date and a death date; gender; an email address; etc. input-shape-books.ttl schema:BookShape After running RDFGraphGen on the input SHACL shapes \ufb01le listed above, and setting the parameter entityCount to 1, below is an example of one generated synthetic RDF graph: output-graph-books.ttl <http://example.org/ns#Node101> a schema:Person ; The SHACL constraints on the property schema:identifier de\ufb01ne a pattern, and the generated value for the prop- erty in the entity corresponds to that pattern. This is achieved by generating a textual string based on the template using the exrex Python library. The name of the book is randomly chosen from a prede\ufb01ned set of book titles, contained in the generator. The list can be modi\ufb01ed and upgraded by users, whenever necessary, just like all the other prede\ufb01ned sets of values. The property schema:bookEdition has a value from the appropriate enumeration for that property, "
      },
      {
        "text": " titles, contained in the generator. The list can be modi\ufb01ed and upgraded by users, whenever necessary, just like all the other prede\ufb01ned sets of values. The property schema:bookEdition has a value from the appropriate enumeration for that property, as de\ufb01ned in the Schema.org vocabulary. The property schema:genre has a minimum (2) and a maximum (4) count constraint, so the generator has generated 3 genres for the synthetic entity. The book genres are also selected randomly from a prede\ufb01ned list, which comes with the generator. The author property points to another SHACL shape and has a minimum (1) and a maximum (3) count constraint. So, in this case, two author entities are generated and added as values for that property. The two author entities are then also fully generated by RDFGraphGen, based on the SHACL constrains. A.2 An Example of Using the \u201cschema:TVSeries\u201d Class from Schema.org Here we have an example which uses the schema:TVSeries class from the Schema.org vocabulary [11]. "
      },
      {
        "text": "tities are then also fully generated by RDFGraphGen, based on the SHACL constrains. A.2 An Example of Using the \u201cschema:TVSeries\u201d Class from Schema.org Here we have an example which uses the schema:TVSeries class from the Schema.org vocabulary [11]. This class represents entities for TV series. The SHACL shape \ufb01le which de\ufb01nes its constraints, contains de\ufb01nitions of the following about each TV series entity: it can have a director; it can have a minimum of 3 actors; it can have numerous seasons and episodes, but the number of seasons should be lower than the number of episodes; it can have a title EIDR which follows a speci\ufb01c pattern; etc. Additionally, the SHACL shape \ufb01le listed below contains de\ufb01nitions of SHACL constraints for the directors and actors of the TV series. They are both entities from the schema:Person class from Schema.org, and they have the usual property constraints which we already saw in the previous examples. schema:ActorShape Below is the content of one synthetic "
      },
      {
        "text": "ors and actors of the TV series. They are both entities from the schema:Person class from Schema.org, and they have the usual property constraints which we already saw in the previous examples. schema:ActorShape Below is the content of one synthetic RDF graph, generated by RDFGraphGen with entityCount set to 1. output-graph-tvseries.ttl <http://example.org/ns#Node101> a schema:Person ; schema:email \"denna_sosa@gmail.com\" ; schema:familyName \"Sosa\" ; schema:gender \"female\" ; schema:givenName \"Denna\" ; schema:telephone \"921-682-3863852\" ; sh:description schema:DirectorShape . <http://example.org/ns#Node102> a schema:Person ; schema:gender \"female\" ; schema:name \"Debi Snow\" ; sh:description schema:ActorShape . <http://example.org/ns#Node103> a schema:Person ; schema:gender \"male\" ; schema:name \"Martainn Foster\" ; sh:description schema:ActorShape . <http://example.org/ns#Node104> a schema:Person ; schema:gender \"male\" ; schema:name \"Waine Mcclain\" ; sh:description schema:ActorShape . In th"
      },
      {
        "text": " schema:Person ; schema:gender \"male\" ; schema:name \"Martainn Foster\" ; sh:description schema:ActorShape . <http://example.org/ns#Node104> a schema:Person ; schema:gender \"male\" ; schema:name \"Waine Mcclain\" ; sh:description schema:ActorShape . In this example, the TV series SHACL shape contains two properties that point to other SHACL shapes: one to a director entity, and one to actor entities. The director entity constraint does not have a minimum or maximum cardinality constraint, so a single director entity is generated for each TV series. On the other hand, the actor entity constraint has a minimum cardinality of 3, so at least 3 actor entities are generated and placed in the corresponding semantic relation to the TV series entity. The number of seasons is constrained to be less than the number of episodes, and the generator abides to this. The schema:season property is constrained in the input SHACL \ufb01le to have the same value as the schema:numberOfSeasons property, and this is fo"
      },
      {
        "text": " number of seasons is constrained to be less than the number of episodes, and the generator abides to this. The schema:season property is constrained in the input SHACL \ufb01le to have the same value as the schema:numberOfSeasons property, and this is followed by the generator. Additionally, the schema:startDate property is de\ufb01ned to have a date value which is less then the date value of schema:datePublished property, while schema:datePublished should be less or equal to schema:endDate. These constraints are again respected by RDFGraphGen, as can be seen from the generated RDF graph. A.3 An Example of Using Classes and Properties from an Unknown Ontology The examples so far involved well-known entity types from Schema.org. As we explained before, the generator has several prede\ufb01ned sets of possible values for the more common Schema.org classes and properties, for usability sake. However, the main feature of RDFGraphGen is its universality and domain independence. In order to show that it c"
      },
      {
        "text": "e, the generator has several prede\ufb01ned sets of possible values for the more common Schema.org classes and properties, for usability sake. However, the main feature of RDFGraphGen is its universality and domain independence. In order to show that it can work with other ontologies, which are not well-known for the generator, we will use an example here which uses the non-existent example ontology, with it\u2019s classes and properties. input-shape.ttl When we use the RDFGraphGen generator on the input \ufb01le, with the entityCount value set to 2, we get a synthetic RDF graph which follows the SHACL constraints, and looks like the sample below. output-graph.ttl \"pbuXXfsY\", \"rO3mdpRk\" ; ex:dateOfProduction \"1957-04-10\"^^xsd:date ; ex:dateOfExpiration \"2007-04-10\"^^xsd:date ; ex:name \"1bCJ3ZXgGK\" ; sh:description schema:ExampleShape . The ex:name property, even though it is not known for the generator, has a speci\ufb01ed datatype in the SHACL \ufb01le (xsd:string), and a maximum and minimum length. This help"
      },
      {
        "text": "007-04-10\"^^xsd:date ; ex:name \"1bCJ3ZXgGK\" ; sh:description schema:ExampleShape . The ex:name property, even though it is not known for the generator, has a speci\ufb01ed datatype in the SHACL \ufb01le (xsd:string), and a maximum and minimum length. This helps the generator generate a random value for each synthetic RDF triple which uses this property as a predicate. The ex:identifier property has no de\ufb01ned datatype, so the generator assumes string values. Given the cardinality constraints of 3 and 6, the RDFGraphGen generates random string values for the synthetic RDF triples it generates with this property. The ex:dateOfProduction property does not have a datatype, but has a SHACL constraint relating it to another property, which has xsd:date as minimum and maximum values. This leads the generator to assume that both properties have dates as values. The SHACL constraints de\ufb01ne that ex:dateOfProduction has to have a lesser value than the ex:dateOfExpiration property, and additionally that the "
      },
      {
        "text": "inimum and maximum values. This leads the generator to assume that both properties have dates as values. The SHACL constraints de\ufb01ne that ex:dateOfProduction has to have a lesser value than the ex:dateOfExpiration property, and additionally that the ex:dateOfExpiration property has a value in the de\ufb01ned range. Following these SHACL constraints, the RDFGraphGen generates the output shown above. "
      }
    ],
    "ual": "did:dkg:otp:2043/0x5cac41237127f94c2d21dae0b14bfefa99880630/4226607"
  }
]
